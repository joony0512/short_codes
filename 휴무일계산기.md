지난 2022년, 병호는 목표를 위해 아주 열심히 달려왔다. 너무 열심히 한 탓일까?.. 2023년 병호는 자신이 얼마나 합법적으로 쉴 수 있는지 계산해보려고 한다. 2023년에는 다행히 윤년이 아니다! 즉, 2월은 28일 까지뿐이라 하루를 덜 일할 수 있다.
몇몇 공휴일이 주말과 겹쳐서 슬픈 직장인들을 위해, 평일을 공휴일로 지정하여 쉴 수 있도록 임시 공휴일이 지정된다. 임시 공휴일은 다음과 같은 규칙으로 지정된다.
공휴일로 지정된 날이 토요일인 경우, 이전 금요일이 임시 공휴일로 지정된다.  
만약 금요일도 공휴일로 지정되어 있다면, 해당 금요일 이전의 가장 가까운 평일이 임시 공휴일로 지정된다.  
공휴일로 지정된 날이 일요일인 경우, 해당 날 이후 가장 가까운 월요일이 임시 공휴일로 지정된다.  
만약 월요일도 공휴일로 지정되어 있다면, 해당 월요일 이후 가장 가까운 평일이 임시 공휴일로 지정된다. 규칙을 통해 임시 공휴일을 지정할 때, 전년도나 다음 연도로 넘어가는 경우 임시 공휴일을 지정하지 않는다. 
  
2022년 열심히 일한 병호를 위해 마이다스 아이티에서 특별히 휴가를 N일 부여하였다. 병호는 원하는 언제든 휴가를 사용할 수 있다!  
병호는 여자친구와 해외여행을 가기 위해 전략적으로 휴가를 사용하여 연속적으로 길~게 쉬려고 한다. 병호가 전략적으로 휴가를 사용했을 때, 연속으로 가장 오래 쉴 수 있는 기간 및 휴가 시작 날과 마지막 날의 월/일을 구해보자!
입력 X: 1월 1일이 무슨 요일인지 의미한다. 1은 월요일, 2는 화요일, 3은 수요일, … 7은 일요일을 의미한다. ( 1<=X<=7) H(M,D): 공휴일 정보로 M월 D일이 공휴일 임을 의미한다. N: 병호가 받은 휴가 일. N은 15보다 작은 자연수이다. 출력 병호가 연속적으로 쉴 수 있는 기간과 휴가 시작 월, 일 휴가 끝 월, 일을 차례로 반환한다. 답이 여러 개라면 휴가 시작이 가장 빠른 답을 반환한다.
X H N return 7 [[1,1],[1,21],[1,22],[1,23],[3,1],[5,5],[5,27],[6,6],[8,15],[9,28],[9,29],[9,30],[10,3],[10,9],[12,25]] 3 [11,9,23,10,3]

![image](https://github.com/joony0512/short_codes/assets/109457820/6254e775-831c-4ab3-8e95-1666bd30636c)

H = [[1,1],[1,21],[1,22],[1,23],[3,1],[5,5],[5,27],[6,6],[8,15],[9,28],[9,29],[9,30],[10,3],[10,9],[12,25]]

def solution(X, H, N):
    calender = []
    num = 0
    base_holiday = []
    bonus = 0
    bonus_list =[]
    for i in range(1, 13):
        days =[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        for j in range(days[i-1]):
            calender.append([i, j+1])

    for k in range(1, len(calender)) :
        if (k+X-1) % 7 in [1, 2, 3, 4, 5] and calender[k -1] in H :
            print('쉬는공휴일',calender[k -1])
            num +=1

        elif (k+X-1) % 7 in [0, 6] and calender[k -1] in H:
            print('못쉬는 공휴일',(k+X-1) % 7, calender[k -1] )
            bonus +=1
            if (k+X-1) % 7 ==0 :
                if calender[k] in H:
                    if calender[k+1] in H:
                        bonus_list.append(calender[k+2])
                    else:
                        bonus_list.append(calender[k+1])
                else :
                    bonus_list.append(calender[k])
            if (k+X-1) % 7 ==6 :
                if calender[k-2] in H:
                    if calender[k-3] in H :
                        bonus_list.append(calender[k-4])
                    else:
                        bonus_list.append(calender[k-3])
                else :
                    bonus_list.append(calender[k-2])

############# 

        if (k+X-1) % 7 in [0, 6] :
                base_holiday.append(calender[k -1])
    print('base holiday', len(base_holiday))


    print('bonus list', bonus_list)
    H = H + bonus_list
    print('H', H)
#############################


    hol = [104, 105]
    if X in [1,2,3,4,5] :
        answer = hol[0] + num + bonus
    else :
        answer = hol[1] + num + bonus
#################################

    All_h_day = base_holiday + H

    check_cal = []

    for day in calender:
        if day in All_h_day:
            check_cal.append(day)
        else:
            check_cal.append(0)

    max_vacation = []  # 가장 긴 휴가를 저장할 리스트
    current_vacation = []  # 현재 휴가를 저장할 리스트
    zero_count = 0  # 연속 0의 개수를 세는 변수

    for i, element in enumerate(calender):
        if element in All_h_day:
            current_vacation.append(element)
        else:
            zero_count += 1
            if zero_count <= N:
                current_vacation.append(element)
            else:
                current_vacation.append([0])
                zero_count = 0  # N을 초과하는 경우 0으로 초기화

        if len(current_vacation) > len(max_vacation):
            max_vacation = current_vacation[:]

    max_sequence = []  # 가장 긴 연속된 휴가일을 저장할 리스트
    current_sequence = []  # 현재 휴가를 저장할 리스트

    for element in max_vacation:
        if element != [0]:
            current_sequence.append(element)
        else:
            if len(current_sequence) > len(max_sequence):
                max_sequence = current_sequence[:]
            current_sequence = []

    if len(current_sequence) > len(max_sequence):
        max_sequence = current_sequence

    return [len(max_sequence),max_sequence[0][0], max_sequence[0][1], max_sequence[-1][0], max_sequence[-1][1]]
